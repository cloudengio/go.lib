// Copyright 2018 Cosmos Nicolaou. All rights reserved.
// Use of this source code is governed by the Apache-2.0
// license that can be found in the LICENSE file.

// The following enables go generate to generate the go types and vales for the required linux cpp definitions.
//go:generate bash generate-go-definitions.sh fanotify defines_linux.go

// Package fanotify provides access to the linux fanotify API.
package fanotify

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"sync"
	"syscall"
	"unsafe"
)

// EventQueue represents an fanotify event queue.
type EventQueue struct {
	name        string
	fd          int
	lock        sync.RWMutex
	includeFD   bool
	noPath      bool
	forwardSelf bool
	closed      bool
}

const (
	supportedVersion = 3
	minEventSize     = priv_SizeofFanotifyEventMetadata
	responsSize      = priv_SizeofFanotifyResponse
)

var (
	codec binary.ByteOrder
)

type faerror struct {
	terminal bool
	err      error
}

func (fe *faerror) Error() string {
	return fe.err.Error()
}

func init() {
	// determine endianness, just in case the CPU is an arm for example.
	var val int = 0x1
	bs := (*[int(unsafe.Sizeof(0))]byte)(unsafe.Pointer(&val))
	if bs[0] == 1 {
		codec = binary.LittleEndian
	} else {
		codec = binary.BigEndian
	}
}

// NewQueue creates a new event queue and is a thin wrapper on fanotify_init(2).
func NewQueue(name string, groupFlags FAN_GROUP_FLAGS, eventFlags FAN_EVENT_FLAGS, ch chan Event) (*EventQueue, error) {
	fd, errno := fanotify_init(groupFlags, eventFlags)
	if errno != 0 {
		return nil, errno
	}
	eq := &EventQueue{
		name: name,
		fd:   fd,
	}
	go func() {
		eq.loop(ch)
	}()
	return eq, nil
}

// EventOptions influences how events are processed. The default values
// result in the event file descriptor being closed and the pathname resolved.
type EventOptions struct {
	// IncludeFileDescriptor controls whether the event contains
	// a valid file descriptor, if not set, the file descriptors are
	// closed automatically as soon as the event is read.
	IncludeFileDescriptor bool

	// NaPathNames controls whether the event contains a valid path,
	// if not set, the returned file descriptor, prior to being closed (if
	// IncludeFileDescriptor is false), is used to obtain the path name
	// that this event pertains to.
	NoPathNames bool

	// ForwardSelfNotifications controls whether events generated by the
	// current process are forwarded as events or not.
	ForwardSelfNotifications bool
}

// SetOptions sets the available options on this event queue.
func (eq *EventQueue) SetOptions(opts EventOptions) {
	eq.lock.Lock()
	eq.includeFD = opts.IncludeFileDescriptor
	eq.noPath = opts.NoPathNames
	eq.forwardSelf = opts.ForwardSelfNotifications
	eq.lock.Unlock()
}

// Mark mirrors fanotify_mark(2).
func (eq *EventQueue) Mark(flags FAN_MARK_FLAGS, mask FAN_MASK_FLAGS, path string) error {
	path = filepath.Clean(path)
	dirFD := 0
	// dir FD is ignored for absolute path names.
	if !filepath.IsAbs(path) {
		dirFD = priv_AT_FDCWD
	}
	if errno := fanotify_mark(eq.fd, flags, mask, dirFD, path); errno != 0 {
		return fmt.Errorf("failed to set mask on %v: %v", path, errno)
	}
	return nil
}

const (
	prefix    = "/proc/self/fd/"
	prefixLen = len(prefix)
	prefixMax = prefixLen + 20
)

// PathnameForFD returns the pathname associated with the supplied file
// descriptor.
func PathnameForFD(fd int32) (string, error) {
	buf := make([]byte, prefixLen, prefixMax)
	copy(buf, prefix)
	buf = append(buf, []byte(strconv.FormatInt(int64(fd), 10))...)
	return os.Readlink(string(buf))
}

// Event represents a single fanotify event. It is possilbe that queue overflow
// may occur and it is left to the client to take whatever action it deems
// appropriate.
type Event struct {
	// Error represents any errors encountered when processing events. Such
	// errors may be 'terminal' in that the event loop terminates, or retryable,
	// as in a queue overflow. Use 'IsTerminalError' to determine which case
	// it is.
	Error error
	// Mask corresponds to fanotify_event_metadata.mask.
	Mask FAN_EVENT_MASK
	// FD corresponds to  fanotify_event_metadata.fd unless AutoClose mode
	// is in effect, in which case it will be -1.
	FD int32
	// PID corresponds to fanotify_event_metadata.pid.
	PID int32
	// Path corresponds to the pathname for the file or directory that this
	// event pertains to.
	Path string
}

// String implements Stringer.
func (e Event) String() string {
	buf := bytes.NewBuffer(make([]byte, 0, 128))
	fmt.Fprintf(buf, "Path: %q, Mask %v, FD %d, PID %d", e.Path, e.Mask, e.FD, e.PID)
	if e.Error != nil {
		fmt.Fprintf(buf, ", Error: %v", e.Error)
	}
	return buf.String()
}

// Respond writes a response to the fanotify event, either allowing or denying
// access. The file descriptor is closed once the response has been written.
func (eq *EventQueue) Respond(event *Event, allow bool) error {
	fd := int(event.FD)
	if (event.Mask & (EVENT_FAN_OPEN_PERM | EVENT_FAN_ACCESS_PERM)) != 0 {
		response := make([]byte, responsSize)
		codec.PutUint32(response[0:4], uint32(fd))
		val := uint32(priv_FAN_DENY)
		if allow {
			val = priv_FAN_ALLOW
		}
		codec.PutUint32(response[4:8], val)
		_, err := syscall.Write(eq.fd, response)
		if err != nil {
			syscall.Close(fd)
			return fmt.Errorf("EventQueue.Respond: write on %v: %v", eq.fd, err)
		}
	}
	return syscall.Close(fd)
}

// IsTerminalError returns true if the supplied error indicates a terminal
// error, that is, that the internal event loop for the event queue that
// generated this error has shutdown. It will panic if the error supplied
// was not returned via an Event.
func IsTerminalError(err error) bool {
	return err.(*faerror).terminal
}

func terminal(format string, args ...interface{}) error {
	return &faerror{true, fmt.Errorf(format, args...)}
}

func retryable(format string, args ...interface{}) error {
	return &faerror{false, fmt.Errorf(format, args...)}
}

// Close closes the FD associated with this event queue. A final event
// will be sent on the event channel indicating that a terminal error has
// occurred and that the queue has been closed.
func (eq *EventQueue) Close() error {
	eq.lock.Lock()
	eq.closed = true
	eq.lock.Unlock()
	return syscall.Close(int(eq.fd))
}

func setupEpoll(fd int) (int, error) {
	efd, err := syscall.EpollCreate(1)
	if err != nil {
		return -1, err
	}
	err = syscall.EpollCtl(efd, priv_EPOLL_CTL_ADD, fd, &syscall.EpollEvent{Events: priv_EPOLLIN})
	if err != nil {
		syscall.Close(efd)
		return -1, err
	}
	return efd, nil
}

func (eq *EventQueue) loop(ch chan Event) {
	defer close(ch)
	buf := make([]byte, minEventSize*1024)
	myPid := int32(os.Getpid())
	efd, err := setupEpoll(eq.fd)
	if err != nil {
		ch <- Event{Error: terminal("epoll setup: %v", err)}
		return
	}
	defer func() {
		syscall.Close(efd)
	}()
	epoll := make([]syscall.EpollEvent, 1)
	fd := eq.fd
	for {
		// Use epoll wait to allow for periodically checking to determine if
		// the event queue has been closed.
		nepoll, err := syscall.EpollWait(efd, epoll, 100)
		eq.lock.RLock()
		closed := eq.closed
		eq.lock.RUnlock()
		if closed {
			ch <- Event{Error: terminal("event queue closed")}
			return
		}
		if err != nil {
			ch <- Event{Error: terminal("epoll error: %v", err)}
			return
		}
		if nepoll == 0 {
			// timeout.
			continue
		}

		bufSize, err := syscall.Read(fd, buf)
		if err != nil {
			if err == os.ErrClosed {
				ch <- Event{Error: terminal("file descriptor closed")}
			} else {
				ch <- Event{Error: retryable("failed reading events: %v", err)}
				continue
			}
			return
		}
		next := 0
		nevents := 0
		eq.lock.RLock()
		includeFD := eq.includeFD
		resolvePath := !eq.noPath
		forwardSelf := eq.forwardSelf
		eq.lock.RUnlock()
		var event Event
		for {
			event = Event{}
			eventStart := next
			if left := bufSize - eventStart; left < minEventSize {
				ch <- Event{Error: retryable("short metadata read after %v events: %v < %v", nevents, left, minEventSize)}
			}
			size := int(codec.Uint32(buf[next : next+4]))
			next += 4
			if vers := buf[next]; vers != supportedVersion {
				ch <- Event{Error: terminal("unsupported event data version, got %v, want %v", vers, supportedVersion)}
				close(ch)
				return
			}
			next += 2
			if mdlen := codec.Uint16(buf[next : next+2]); mdlen != minEventSize {
				ch <- Event{Error: terminal("unexpected metadata len, got %v, want %v", mdlen, minEventSize)}
				close(ch)
				return
			}
			next += 2
			event.Mask = FAN_EVENT_MASK(codec.Uint64(buf[next : next+8]))
			next += 8
			event.FD = int32(codec.Uint32(buf[next : next+4]))
			next += 4
			event.PID = int32(codec.Uint32(buf[next : next+4]))
			next += 4
			if int(event.FD) == int(priv_FAN_NOFD) {
				event.Error = retryable("queue overflow: %v events read, %v bytes remaining", nevents, bufSize-eventStart)
			} else {
				if forwardSelf || (event.PID != myPid) {
					if resolvePath {
						p, err := PathnameForFD(int32(event.FD))
						if err != nil {
							event.Error = retryable("failed to obtain pathname for %v: %v", event, err)
						}
						event.Path = p
					}
					if !includeFD {
						syscall.Close(int(event.FD))
						event.FD = -1
					}
				}
			}
			ch <- event
			nevents++
			next = eventStart + size
			if next >= bufSize {
				break
			}
		}
	}
}
